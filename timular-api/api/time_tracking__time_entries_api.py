# coding: utf-8

"""
    Timeular Public API

     Welcome to the documentation of Timeular Public API v2. If you want to have a look at the older and deprecated API v1 please just click on the following link: [Timeular Public API v1](./?v=v1)  You can try all requests here, in documentation, with use of `Try it out` button (available in each endpoint description after folding it out).  Most of endpoints are secured. In order to access them you have to provide *Access Token*. To do so, click on `Authorize` button below and provide `'Bearer *your_access_token*'` as a value for `Authorization` request header. To obtain *Access Token* you have to sign-in with pair of *API Key* and *API Secret* first. API Key & API Secret can be generated on [Profile website](https://profile.timeular.com/#/app/) or, if you have Access Token already, with `POST` request to `/developer/api-access`.  **Warning:** authentication flow may change soon due to active development of Timeular and its API.  If you have any questions, please visit [Support page](http://support.timeular.com) and ask them there.  Happy API browsing!  # noqa: E501

    OpenAPI spec version: 1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from timular-api.api_client import ApiClient


class TimeTrackingTimeEntriesApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_time_entry(self, **kwargs):  # noqa: E501
        """Create Time Entry  # noqa: E501

        With this endpoint, you can create a new Time Entry. It should be connected to an Activity and have a duration no shorter than 1 minute. A Note can be provided too, but it's not required. Within this Note, you can  refer one or more Tags or Mentions, each of the prefixes must be  configured with the start and the end index within the Note text and can be  defined with a key. If key is not defined a random id will be generated and  assigned. If you are referring to an existing Tag or Mention you can provide that key  but the content of the Tag or Mention must be the same.  If the related Activity is bound to some Integration, let's say JIRA Project, JIRA task IDs is a valid Tag too. Time Entry will be created even if it overlaps with other Time Entries – in result existing Time Entries will be split or deleted in such manner, that new one will fit without overlapping.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_time_entry(async=True)
        >>> result = thread.get()

        :param async bool
        :param TimeEntryCreationRequest properties_of_a_new_time_entry: properties of a new Time Entry
        :return: TimeEntryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_time_entry_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_time_entry_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_time_entry_with_http_info(self, **kwargs):  # noqa: E501
        """Create Time Entry  # noqa: E501

        With this endpoint, you can create a new Time Entry. It should be connected to an Activity and have a duration no shorter than 1 minute. A Note can be provided too, but it's not required. Within this Note, you can  refer one or more Tags or Mentions, each of the prefixes must be  configured with the start and the end index within the Note text and can be  defined with a key. If key is not defined a random id will be generated and  assigned. If you are referring to an existing Tag or Mention you can provide that key  but the content of the Tag or Mention must be the same.  If the related Activity is bound to some Integration, let's say JIRA Project, JIRA task IDs is a valid Tag too. Time Entry will be created even if it overlaps with other Time Entries – in result existing Time Entries will be split or deleted in such manner, that new one will fit without overlapping.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_time_entry_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param TimeEntryCreationRequest properties_of_a_new_time_entry: properties of a new Time Entry
        :return: TimeEntryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['properties_of_a_new_time_entry']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_time_entry" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'properties_of_a_new_time_entry' in params:
            body_params = params['properties_of_a_new_time_entry']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;charset=UTF-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AuthorizationHeader']  # noqa: E501

        return self.api_client.call_api(
            '/time-entries', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeEntryResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_time_entry(self, time_entry_id, **kwargs):  # noqa: E501
        """Delete a Time Entry  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_time_entry(time_entry_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str time_entry_id: ID of a Time Entry, eg. `987` (required)
        :return: SuccessWithIgnoredErrorsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_time_entry_with_http_info(time_entry_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_time_entry_with_http_info(time_entry_id, **kwargs)  # noqa: E501
            return data

    def delete_time_entry_with_http_info(self, time_entry_id, **kwargs):  # noqa: E501
        """Delete a Time Entry  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_time_entry_with_http_info(time_entry_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str time_entry_id: ID of a Time Entry, eg. `987` (required)
        :return: SuccessWithIgnoredErrorsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['time_entry_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_time_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'time_entry_id' is set
        if ('time_entry_id' not in params or
                params['time_entry_id'] is None):
            raise ValueError("Missing the required parameter `time_entry_id` when calling `delete_time_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'time_entry_id' in params:
            path_params['timeEntryId'] = params['time_entry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;charset=UTF-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AuthorizationHeader']  # noqa: E501

        return self.api_client.call_api(
            '/time-entries/{timeEntryId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SuccessWithIgnoredErrorsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_time_entry(self, time_entry_id, **kwargs):  # noqa: E501
        """Edit a Time Entry  # noqa: E501

        With this endpoint you can edit existing Time Entry. When changing Activity ID please note, that both new and old Activity attached to Time Entry have to belong to same Integration. To remove a Note, just set the complete object to null and all values  within the object will be deleted too.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.edit_time_entry(time_entry_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str time_entry_id: ID of a Time Entry, eg. `987` (required)
        :param TimeEntryEditionRequest properties_to_change: properties to change
        :return: TimeEntryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.edit_time_entry_with_http_info(time_entry_id, **kwargs)  # noqa: E501
        else:
            (data) = self.edit_time_entry_with_http_info(time_entry_id, **kwargs)  # noqa: E501
            return data

    def edit_time_entry_with_http_info(self, time_entry_id, **kwargs):  # noqa: E501
        """Edit a Time Entry  # noqa: E501

        With this endpoint you can edit existing Time Entry. When changing Activity ID please note, that both new and old Activity attached to Time Entry have to belong to same Integration. To remove a Note, just set the complete object to null and all values  within the object will be deleted too.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.edit_time_entry_with_http_info(time_entry_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str time_entry_id: ID of a Time Entry, eg. `987` (required)
        :param TimeEntryEditionRequest properties_to_change: properties to change
        :return: TimeEntryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['time_entry_id', 'properties_to_change']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_time_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'time_entry_id' is set
        if ('time_entry_id' not in params or
                params['time_entry_id'] is None):
            raise ValueError("Missing the required parameter `time_entry_id` when calling `edit_time_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'time_entry_id' in params:
            path_params['timeEntryId'] = params['time_entry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'properties_to_change' in params:
            body_params = params['properties_to_change']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;charset=UTF-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AuthorizationHeader']  # noqa: E501

        return self.api_client.call_api(
            '/time-entries/{timeEntryId}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeEntryResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_time_entries_in_range(self, stopped_after, started_before, **kwargs):  # noqa: E501
        """Find Time Entries in given range  # noqa: E501

        Find Time Entries which have at least one millisecond in common with provided time range.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_time_entries_in_range(stopped_after, started_before, async=True)
        >>> result = thread.get()

        :param async bool
        :param str stopped_after: Timestamp which matches all Time Entries stopped after it. Eg. `2017-01-01T00:00:00.000`. (required)
        :param str started_before: Timestamp which matches all Time Entries started before it. Eg. `2017-12-31T23:59:59.999`. (required)
        :return: TimeEntriesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_time_entries_in_range_with_http_info(stopped_after, started_before, **kwargs)  # noqa: E501
        else:
            (data) = self.get_time_entries_in_range_with_http_info(stopped_after, started_before, **kwargs)  # noqa: E501
            return data

    def get_time_entries_in_range_with_http_info(self, stopped_after, started_before, **kwargs):  # noqa: E501
        """Find Time Entries in given range  # noqa: E501

        Find Time Entries which have at least one millisecond in common with provided time range.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_time_entries_in_range_with_http_info(stopped_after, started_before, async=True)
        >>> result = thread.get()

        :param async bool
        :param str stopped_after: Timestamp which matches all Time Entries stopped after it. Eg. `2017-01-01T00:00:00.000`. (required)
        :param str started_before: Timestamp which matches all Time Entries started before it. Eg. `2017-12-31T23:59:59.999`. (required)
        :return: TimeEntriesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['stopped_after', 'started_before']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_time_entries_in_range" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'stopped_after' is set
        if ('stopped_after' not in params or
                params['stopped_after'] is None):
            raise ValueError("Missing the required parameter `stopped_after` when calling `get_time_entries_in_range`")  # noqa: E501
        # verify the required parameter 'started_before' is set
        if ('started_before' not in params or
                params['started_before'] is None):
            raise ValueError("Missing the required parameter `started_before` when calling `get_time_entries_in_range`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'stopped_after' in params:
            path_params['stoppedAfter'] = params['stopped_after']  # noqa: E501
        if 'started_before' in params:
            path_params['startedBefore'] = params['started_before']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;charset=UTF-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AuthorizationHeader']  # noqa: E501

        return self.api_client.call_api(
            '/time-entries/{stoppedAfter}/{startedBefore}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeEntriesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_time_entry(self, time_entry_id, **kwargs):  # noqa: E501
        """Find Time Entry by its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_time_entry(time_entry_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str time_entry_id: ID of a Time Entry, eg. `987` (required)
        :return: TimeEntryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_time_entry_with_http_info(time_entry_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_time_entry_with_http_info(time_entry_id, **kwargs)  # noqa: E501
            return data

    def get_time_entry_with_http_info(self, time_entry_id, **kwargs):  # noqa: E501
        """Find Time Entry by its ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_time_entry_with_http_info(time_entry_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str time_entry_id: ID of a Time Entry, eg. `987` (required)
        :return: TimeEntryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['time_entry_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_time_entry" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'time_entry_id' is set
        if ('time_entry_id' not in params or
                params['time_entry_id'] is None):
            raise ValueError("Missing the required parameter `time_entry_id` when calling `get_time_entry`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'time_entry_id' in params:
            path_params['timeEntryId'] = params['time_entry_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;charset=UTF-8'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['AuthorizationHeader']  # noqa: E501

        return self.api_client.call_api(
            '/time-entries/{timeEntryId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeEntryResponse',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
